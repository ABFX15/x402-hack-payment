import { NextRequest, NextResponse } from "next/server";
import { getPayment, generateReceiptId } from "@/lib/db";

export interface ReceiptData {
    receiptId: string;
    paymentId: string;
    merchant: {
        id: string;
        name: string;
        wallet: string;
    };
    customer: {
        wallet: string;
    };
    amount: number;
    currency: string;
    description?: string;
    txSignature: string;
    explorerUrl: string;
    createdAt: string;
    completedAt: string;
    status: string;
}

/**
 * GET /api/receipts/[id]
 * 
 * Returns receipt data for a payment
 * Query params:
 *   - format: "json" (default) | "pdf"
 */
export async function GET(
    request: NextRequest,
    { params }: { params: Promise<{ id: string }> }
) {
    const { id } = await params;
    const format = request.nextUrl.searchParams.get("format") || "json";

    // Get payment from database
    const payment = await getPayment(id);

    if (!payment) {
        return NextResponse.json(
            { error: "Receipt not found" },
            { status: 404 }
        );
    }

    // Build receipt data
    const receiptData: ReceiptData = {
        receiptId: generateReceiptId(payment.id),
        paymentId: payment.id,
        merchant: {
            id: payment.merchantId,
            name: payment.merchantName,
            wallet: payment.merchantWallet,
        },
        customer: {
            wallet: payment.customerWallet,
        },
        amount: payment.amount,
        currency: payment.currency,
        description: payment.description,
        txSignature: payment.txSignature,
        explorerUrl: payment.explorerUrl,
        createdAt: new Date(payment.createdAt).toISOString(),
        completedAt: new Date(payment.completedAt).toISOString(),
        status: payment.status,
    };

    // Return JSON by default
    if (format === "json") {
        return NextResponse.json(receiptData);
    }

    // Generate PDF
    if (format === "pdf") {
        const pdfBytes = await generateReceiptPDF(receiptData);

        return new Response(pdfBytes.buffer as ArrayBuffer, {
            status: 200,
            headers: {
                "Content-Type": "application/pdf",
                "Content-Disposition": `attachment; filename="receipt-${receiptData.receiptId}.pdf"`,
            },
        });
    }

    return NextResponse.json(
        { error: "Invalid format. Use 'json' or 'pdf'" },
        { status: 400 }
    );
}

/**
 * Generate a PDF receipt
 * 
 * Note: For production, consider using a proper PDF library like:
 * - @react-pdf/renderer (React-based)
 * - pdfkit (Node.js)
 * - puppeteer (Chrome-based, higher quality)
 * 
 * For now, we generate a simple PDF using basic text formatting
 */
async function generateReceiptPDF(receipt: ReceiptData): Promise<Uint8Array> {
    // Simple PDF generation without external dependencies
    // This creates a valid PDF with basic text content

    const content = `
PAYMENT RECEIPT
===============

Receipt ID: ${receipt.receiptId}
Payment ID: ${receipt.paymentId}

MERCHANT
--------
Name: ${receipt.merchant.name}
Wallet: ${receipt.merchant.wallet}

CUSTOMER
--------
Wallet: ${receipt.customer.wallet}

PAYMENT DETAILS
---------------
Amount: $${receipt.amount.toFixed(2)} ${receipt.currency}
Description: ${receipt.description || "N/A"}
Status: ${receipt.status.toUpperCase()}

TRANSACTION
-----------
Signature: ${receipt.txSignature}
Explorer: ${receipt.explorerUrl}

TIMESTAMPS
----------
Initiated: ${receipt.createdAt}
Completed: ${receipt.completedAt}

---
This receipt was generated by Settlr.
Verify on Solana Explorer: ${receipt.explorerUrl}
`.trim();

    // Create a simple PDF (PDF 1.4 format)
    return createSimplePDF(content, receipt);
}

/**
 * Create a simple PDF document
 * This is a minimal PDF generator - for production use pdfkit or similar
 */
function createSimplePDF(textContent: string, receipt: ReceiptData): Uint8Array {
    const encoder = new TextEncoder();

    // PDF content with proper formatting
    const title = `Payment Receipt - ${receipt.receiptId}`;
    const lines = textContent.split('\n');

    // Build PDF content stream
    let yPos = 750;
    let contentStream = `BT\n/F1 24 Tf\n50 ${yPos} Td\n(${escapeText(title)}) Tj\nET\n`;

    yPos -= 40;
    contentStream += `BT\n/F1 10 Tf\n50 ${yPos} Td\n`;

    for (const line of lines) {
        if (yPos < 50) break; // Stop if we run out of page
        contentStream += `(${escapeText(line)}) Tj\n0 -14 Td\n`;
        yPos -= 14;
    }
    contentStream += `ET\n`;

    // Build the PDF structure
    const objects: string[] = [];

    // Object 1: Catalog
    objects.push(`1 0 obj\n<< /Type /Catalog /Pages 2 0 R >>\nendobj`);

    // Object 2: Pages
    objects.push(`2 0 obj\n<< /Type /Pages /Kids [3 0 R] /Count 1 >>\nendobj`);

    // Object 3: Page
    objects.push(`3 0 obj\n<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 4 0 R /Resources << /Font << /F1 5 0 R >> >> >>\nendobj`);

    // Object 4: Content stream
    const streamBytes = encoder.encode(contentStream);
    objects.push(`4 0 obj\n<< /Length ${streamBytes.length} >>\nstream\n${contentStream}endstream\nendobj`);

    // Object 5: Font
    objects.push(`5 0 obj\n<< /Type /Font /Subtype /Type1 /BaseFont /Courier >>\nendobj`);

    // Build the PDF
    let pdf = `%PDF-1.4\n`;
    const offsets: number[] = [];

    for (const obj of objects) {
        offsets.push(pdf.length);
        pdf += obj + '\n';
    }

    // Cross-reference table
    const xrefOffset = pdf.length;
    pdf += `xref\n0 ${objects.length + 1}\n`;
    pdf += `0000000000 65535 f \n`;
    for (const offset of offsets) {
        pdf += `${offset.toString().padStart(10, '0')} 00000 n \n`;
    }

    // Trailer
    pdf += `trailer\n<< /Size ${objects.length + 1} /Root 1 0 R >>\n`;
    pdf += `startxref\n${xrefOffset}\n%%EOF`;

    return encoder.encode(pdf);
}

/**
 * Escape special characters for PDF text
 */
function escapeText(text: string): string {
    return text
        .replace(/\\/g, '\\\\')
        .replace(/\(/g, '\\(')
        .replace(/\)/g, '\\)');
}
